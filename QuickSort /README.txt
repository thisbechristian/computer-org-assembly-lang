Christian Boni
COE 0147 T/H 1PM
Assignment 1
3/12/14

In this assignment for implementing an efficient sorter, I chose to implement a sorting in place version of QuickSort which uses recursion. Furthermore, I incorporated this QuickSort with a sorting in place version of InsertionSort which is used as a second base case of the recursive QuickSort. I chose QuickSort because I also tried implementing Bubble Sort and after finishing the implementation of both, I compared the two using several identical arrays and by then observing the instruction count of each. I found that the instruction count of Bubble Sort was much higher then that of QuickSort, and it significantly increased when the size of the array increased. Another reason why QuickSort was chosen was because of its O(N*logN) runtime compared to O(N^2) runtime of Bubble Sort. Furthermore, I chose to incorporate InsertionSort into QuickSort as a base case of the recursion after learning about QuickSort in my Data Structures course. I first tried implementing InsertionSort on its own and when sorting identical arrays I found it to have lower instruction counts compared to BubbleSort, in fact these instruction counts were rather close to those of QuickSort (keep in mind I was using rather small arrays). This was a main factor in deciding to incorporate InsertionSort in the base case rather then BubbleSort. Previously I mentioned that InsertionSort is used when the second base case is reached, this case occurs when the sub-array length is less then 11 items long. Furthermore, I had also learned in my Data Structures class that it is efficient to substitute InsertionSort as a base case when the sub-array lengths are generally smaller because by this time a majority of the items are already sorted and this allows for InsertionSort to perform at its better (if not best) run-times. Finally, to deal with the certain special cases of sorting I came up with a few checks to be done before the actual QuickSort algorithm was used. These special cases include when the array is already sorter, when the array contains all of the same values, and when there is only one item in the array. First, I checked if there was only one item in the array by comparing low and high in a set less then. If low wasn’t less then high then there is only one item in the array and thus the QuickSort doesn’t need to be used so it branched to end. Next I implemented a while loop which iterated through the array and checked if the array was previously sorted which also covered the special case of an array of the same value. As a result of all my knowledge to date of sorting my final choice was to implement a recursive, in-place version of QuickSort, and by having its secondary base case as an in-place version of InsertionSort.

As for the implementation of QuickSort in MIPS/MARS, there are 2 main functions, quickSort and partition. The quickSort function takes 2 inputs low ($v0) and high ($v1) corresponding to the first and last index of the array. As stated above this function uses recursion to sort the array. QuickSort is a well known recursive sorting algorithm that sorts an array using pivots, where it puts items less then the pivot on the left side of the array and items greater then the pivot on the right side of the array (unsorted). Then it recursively sorts the left and right side of the array excluding the pivot, since the pivot is the only item which is in its sorted place. There are also various ways of choosing the pivot but in this case, the pivot is chosen by the middle index of the array and sub-arrays. As with any form of recursion in MIPS, a Prologue and Epilogue are used to manipulate the stack and store important variables. However, in this case the Prologue is broken up and separated by a few instructions that check for each base case of the recursion. In my case there are 2 base cases of the recursion, the first is when the length of the sub-array is equal to one, and the second when the length of the sub-array is less then 11 items long. Both base cases have a special Prologue and Epilogue where it only saves and restores the return address. This is done because the other variables aren't used in the base cases and therefore won't need to be saved or restored. However, the Prologue and Epilogue for the normal recursive case functions as expected, saving the return address ($ra), low ($v0), high ($v1), and the pivot ($s2), onto the stack. 

As I mentioned above QuickSort sorts using a pivot and the pivot value is chosen by picking the middle index of the array, but I left out how the items are then repositioned and sorted after the pivot is chosen. This is where the partition function comes in. The partition function also takes 2 inputs low ($v0) and high ($v1) and has 1 output which is the pivot ($s2). The partition function is called once in every recursive case, and it first finds what the value of the pivot is going to be by using the middle index of the array. Once the pivot is found it is then swapped into the last position in the array (high). Now it is time to reposition the items in the array so those less then the pivot will be on the left side and those greater then the pivot on the right. This is done by introducing a new variable named storeIndex which will have its initial value as the first item in the array/sub-array (low). There is then a loop which will go iterate through each item in the array excluding the pivot. Inside the loop will be comparisons with each item to the value of the pivot. If the item is less then or equal to the pivot the item is then swapped into the storeIndex position in the array, and the storeIndex variable is incremented. Once the loop finishes the pivot is then swapped into the storeIndex position. Finally, storeIndex is returned to the quickSort function and is used to create (partition) the left and right sub-arrays.

Lastly is the implementation of InsertionSort. InsertionSort was a simpler sorting algorithm because it discards the use of recursion. InsertionSort takes 3 inputs low ($v0) and high ($v1) corresponding to the first and last index of the array, and the pointer to the original array ($s0). InsertionSort consists primarily of 2 loops, where the second is nested inside the first. The outer loop is used iterate through the entire array “A” starting at the second value or “A[1]” using each value as the current value or “A[i]”. The inner loop then compares A[i] with A[i-x] (where x = 1 initially) and if A[i-x] is greater then A[i] then A[i-x] is stored into A[(i-x) + 1]. After this is done x is incremented and the loop continues as long as A[i] < A[i-x] and (i <= x). The second condition is needed so the to stop the loop when it reaches the first item in the array. Once the inner loop terminates the original current value “A[i] is then stored in the final place of A[i-x] and then the outer loop continues until it reaches the end of the array.